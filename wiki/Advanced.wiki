#summary Advanced Topics.
#labels Documentation-User,Featured

After reading through the GettingStarted page and getting your project integrated with dyn4j, its time to hit some of the more advanced topics to achieve better control over the collision detection and physics pipelines.

<wiki:toc max_depth="3" />

=General=
==Ids==
Each Shape, Fixture/!BodyFixture, and Body are given random UUIDs upon creation.  These ids are used to refer to the objects stored in maps, comparisons, etc.  Currently the ids are read only as to ensure that each is unique.  This may change in a future release.

==User Data==
Each Shape, Fixture/!BodyFixture, and Body (and some other classes, see the Javadocs for details) contain a member variable called userData which is of type Object.

This member can be used to store anything that you want to be associated with the object.

==Settings==
The Settings class contained in the dynamics package is the class used to configure the physics pipeline.  The class is a singleton object and is not thread safe.

You can use this object to set physics settings at any time.  The Settings object is defaulted to the settings that worked best for all the tests in the !TestBed application.

The Settings class is mainly used to configure the performance to accuracy trade off.

==Units==
The default units are Meter, Kilogram, Seconds or MKS.  It is possible to use another measurement system, however, all the default settings in the Settings object and other classes will need to be adjusted.

If possible, always use MKS, when thats not an option use the !UnitConversion class to convert any values to MKS or from MKS.

==Epsilon==
An inherent side effect of finite precision floating point arithmetic is numerical error.  Another problem to deal with is the lack of exact representation of all values.  These two problems cause many algorithms and logic to use an epsilon comparison instead of comparisons between 0.

The Epsilon class attempts to approximate the machine epsilon for a double precision floating point number.  This epsilon is the smallest floating point number such that x + epsilon &ne; x.  This value is used in a number of algorithms within dyn4j and can be used in game code as well via the Epsilon.E property.
  * dyn4j actually uses larger values than epsilon in some cases to improve performance and stability.

=Shapes=
Both the Shape and Body classes implement the Transformable interface.  The Shape class's implementation directly modifies the internal state of the shape.  This is mainly used to locally transform the Shape.  The Body class's implementation modifies the Body's Transform.

  * Shapes can be reused in other Bodies but remember that if you transform a Shape directly it will be transformed for all Bodies you add it to.  Its recommended to avoid this practice.

All Shapes also have a getRadius method.  This method returns the maximum radius of the Shape (the rotation disc radius).

==Convex Hulls==
Another way to create Convex Shapes is to generate one from a point set.  Shapes created this way are called Convex Hulls using the Polygon class as storage.

You can find algorithms to generate convex hulls in the geometry.hull package.  The algorithms generate a minimum convex hull given a point set.  All the algorithms should produce the same result, however one may be faster than another depending on the input.

These are intended for both offline and in-game use.

==Convex Decomposition==
Another way to create Convex Shapes is to decompose a larger concave shape into smaller convex pieces.

As stated in the GettingStarted page, all shapes used in the library must be Convex.  To help with this process some convex decomposition algorithms are provided.  These algorithms operate on simple polygons *without* holes.

Convex decomposition algorithms are in the geometry.decompose package and are used to decompose a simple polygon without holes into a list of convex shapes.  The algorithms provided are not optimal but have acceptable complexity.

Three algorithms are offered, generally producing different results.  If you are using these for offline processing, use each one to obtain the smallest decomposition.

These are intended for both offline and in-game use.

==Segment vs. Segment==
If you ran the !TestBed and took a look at the Terrain test you may noticed that Segment vs. Segment collision "doesn't work".  This is by design and is not intended to work.  Segments are a special case and provided with out Segment vs. Segment _collision resolution_.

The Segment class lives in the geometry package and extends the Convex interface.  Because of this it can be used in collision detection *and in the physics pipeline*.  This class represents a infinitely thin segment.  Because of this, Segment vs. Segment _collision resolution_ does not work however, _collision detection_ does work.

==Creating New Convex Shapes==
If you choose to create your own Shape class you must implement the Convex interface for the new Shapes to be usable by the collision detection and physics pipelines.  The getAxes and getFoci methods are used to support SAT, the getFarthestPoint is used by GJK, and the getFarthestFeature is used by the Manifold Solver.

New Shapes are required to have a final static member named TYPE that is set to an instance of Shape.Type.  The new class should implement/override the getType method and return the static instance.

The Shape.Type class also accepts a parent Shape.Type.  This is used to emulate the hierarchical structure of the classes.  For example, a Rectangle is a polygon, so we define its type as:

{{{
public class Rectangle extends Polygon {
  public static final Shape.Type TYPE = new Shape.Type(Polygon.TYPE, "Rectangle");
}
}}}

=Bodies=
The Body class contains methods to apply linear and angular damping.  This can be useful to simulate fluid/air resistance and also to reduce the total energy in the system.

For initial placement of Bodies, use the translateToOrigin method.  This will translate the Body's center of mass to the origin making it easier to initially place Bodies before starting the simulation.

==Integration With Game Objects==
A common question would be how do I relate my game objects with Bodies in the World?  There are a few ways to choose from:

The Body class can be extended or can be contained in another object or can be completely separate.
  * The Body class can be extended, be careful when overriding methods; make sure you call the super method.
  * The Body class can be contained in another class
  * The Body class can be completely separate by using the userData member variable for association.

All three methods are acceptable and intended for use.  The !TestBed application used for testing the library uses the first method.

==Body States==
The life time of a Body is usually very long.  Over that span the Body's state may change.

A Body becomes "asleep" when the physics engine has determined that it is not moving.  The Body is still tested for collisions but is excluded from the physics pipeline to save time.  Sleeping of a Body only occurs when the Body's linear and angular velocity are below a threshold set in the Settings singleton.  Automatic sleeping can be controlled on a Body by Body basis or globally using the Settings class.

A Body becomes "inactive" when the collision detection system detects that the entire Body is outside the bounds of the world.  The Body no longer participates in collision detection or physics.  This state will never be set automatically if the World has no bounds.

Using the setActive and setAsleep methods you can manually put a Body to sleep or set inactive.

==Applying Forces & Torques==
When applying Forces and Torques to a Body they are queued in an accumulator and not immediately applied.  When a simulation step is performed the stored Forces and Torques are applied to the Bodies and placed in the force and torque member variables.  This is done so that the previous simulation step's force and torque values can be queried via the getForce and getTorque methods.

The Force and Torque classes also feature an isComplete method that can be overridden by sub classes.  This allows a force to be created that may or may not be removed at the end of a world step given the return of the isComplete method.

Applying Forces, Torques, or impulses to a Body will immediately awaken the Body if it was asleep.

==Fixtures & !BodyFixtures==
Fixture is the base class for !BodyFixture.  !BodyFixtures are the only Fixtures allowed to be added to a Body.  The Fixture base class is present to allow users to use the collision detection system without the dynamics engine.

There is a one to one relationship between a Convex Shape and a !BodyFixture.  A Convex Shape must be contained in a !BodyFixture to be added to a Body.  The !BodyFixture class allows shapes to have different dynamics settings.

Each !BodyFixture has its own density, friction and restitution coefficients, and collision Filter.  !BodyFixtures can also be flagged as "sensors."

A sensor is a !BodyFixture who will detect collisions but whose collisions will not be resolved.

Filters can be used to only allow certain !BodyFixtures to collide with other !BodyFixtures.

==Collision Filtering==
Collision filtering is used to only allow a category of Bodies to collide with another category.

Collision filtering is achieved by the Filter interface and the member on the Fixture/!BodyFixture class.

There are two Filter implementations provided, the Filter.DEFAULT_FILTER and the !CategoryFilter (just like Box2D's collision filter, int category + mask).

You can also create your own filter classes to perform more advanced collision filtering by implementing the Filter interface.

There are some gotcha's on this topic:
  * Collision filtering can be tricky; the collision filters can be called in either order filter1.isAllowed(filter2) or filter2.isAllowed(filter1).  This can cause some confusion.  Another problem is if the Filters compared are not the same filter class type.  The !CategoryFilter is conservative and will return true if the class types are not the same.  Because of this, if you choose to make your own filter implementation class, make sure all Fixture/!BodyFixture objects are given an instance of that same class.
  * The Filter.DEFAULT_FILTER class always returns true and is set by default on every Fixture/!BodyFixture created.
  * The Filter on a Fixture/!BodyFixture cannot be null.  Use the Filter.DEFAULT_FILTER instead.

==Shape Editing==
Throughout the life of a Body it may need to change its Shape(s).  For instance, two bodies collide and one body who has two shapes should break into two bodies each with one shape.  Situations where the shapes of a body need to change is called Shape Editing.

To edit the Shapes of a Body simply call the addFixture and removeFixture methods on the Body.

After any editing has been performed make sure to update the body's mass via one of the setMass methods to reflect the changes.

It is generally discouraged that shapes themselves be modified after being added to a body.  Doing so may have unexpected or inaccurate results.

=World=
The World class is the manager for the collision detection and physics systems.  All event listeners, Bodies, Joints, etc. are added to the World object.

In addition some configurable properties of note are:

==Gravity==
The World class will allow you to set the gravity of the world as a vector.  This means you could create gravity in any direction (or none at all).

==Coefficient Mixer==
As stated above, each !BodyFixture instance can have its own friction and restitution values.  Because of this, these values must be combined so that the contact solver can solve collision.

The CoefficientMixer class can be used to override the standard friction and restitution mixing routines.

=Collision Detection=
The collision detection system is a three tier architecture:

Broadphase -&gt; Narrowphase -&gt; Manifold Solver

The broadphase collision detector is a O(n<sup>2</sup>) detector that determines possible collision pairs.  After obtaining all the possible collision pairs, the pairs are passed to the narrowphase collision detector.  These algorithms should be fast and inaccurate yet conservative.

The narrowphase detector tests each Shape of the first Body against each Shape of the second Body.  If any combination of Shapes collide, the result is passed to the Manifold Solver.

The manifold solver will determine the points on the Shapes that will be used for the physics pipeline.

==Narrowphase==
Two implementations of the !NarrowphaseDetector interface are provided: SAT and GJK.  The GJK algorithm is used by default.

==Using Collision Detection Only==
The collision detection system can be used without the physics pipeline.  Create a class that implements the Collidable interface.  This class will serve as a replacement for the Body class.  Then perform the process outlined above in your own World class.

You can also use the current Body and World classes and implement the necessary listeners to effectively turn off the dynamics portion of the library.

==Static Collision Detection Queries==
The collision detector classes also allow for static collision detection queries.  Just pass the respective values to the detect methods.

In addition to this, you can use the faster boolean result methods if you don't plan to use the extra information provided by the standard detect methods.

==Continuous Collision Detection (CCD)==
Continuous collision detection is aimed at solving the "tunneling" problem.  Tunneling occurs when a fast moving object starts on one side of another object and after one time step is on the other side of that object.  This can happen when Bodies are fast or thin.

The implementation used in dyn4j is called Conservative Advancement.  This method is used in Bullet, Box2d and a number of other physics engines.  The implementation in dyn4j computes the exact time of impact within a specified tolerance.

After detection of a missed collision, the bodies are linearly interpolated to the time of impact.  Next the closest points on the bodies are solved so that the bodies begin to overlap.  This causes the discrete collision detection to catch the collision in the next time step.  Time is not conserved.

This process is performed at the end of each time step.

=Event Listening=
The World class contains a number of event listeners used to receive notifications when an event occurs.
  * *NEVER modify/remove/add Bodies or Joints during a call to World.update(double)*.  This can cause unexpected results and runtime errors.  If you are listening for events, save the events for later processing.  After the World.update(double) method returns you should respond to the queued events.
  * If you have multithreading enabled make sure that your listener implementations are thread safe.

There is one exception.  If you listen for the Step events, you can respond to events at this time.

==Out of Bounds Event==
As described above, when a Body goes out of bounds it is set to inactive.

To receive a notification of this event extend the !BoundsAdapter class or implement the !BoundsListener interface and set it in the World object using the setBoundsListener method.

==Implicit Destruction Event==
When a call to the World.remove(Body) or World.remove(Joint) is made some joints and contacts may be destroyed.

You can receive notification of these events by extending the !DestructionAdapter class or by implementing the !DestructionListener interface.  Just like the !BoundsListener the !DestructionListener is set via the world object.

==Step Event==
When a call to the World.update(double) is made a simulation step is not always taken.  A better simulation results if the steps taken are the same elapsed time.

The !StepAdapter class and !StepListener interface are provided so that you know when a simulation step is performed.  There are two events to listen for: begin and end.

  * These will be called every time a World.updatev(double) call is made.

As stated above, you may use this event to perform updates on Bodies/Joints and the World for any queued events that happened during the time step.

==Collision Event==
When Bodies are detected as colliding by the various phases the !CollisionListener set on the World object is notified.

There are three events that can be called:
  * Broadphase - Called when two Bodies are found to be in collision by the Broadphase
  * Narrowphase - Called when two Bodies are found to be in collision by the Narrowphase
  * Manifold - Called when a contact manifold is found between two Bodies

Each of the the events should return a boolean result.  The returned boolean indicates whether the collision processing should continue.

The !CollisionAdapter, which is the default, will always return true for all three methods.

==Contact Event==
When Bodies come into contact the physics engine must resolve that contact.  The !ContactAdapter class and !ContactListener interface are used to receive contact events.  

The contact events include:
  * Begin - A contact was created between two Bodies
  * Persist - A contact is still active between two Bodies
  * End - A contact no longer exists between two Bodies
  * Sensed - A contact exists between a sensor Body and another Body
  * !PreSolve- Called for all contacts that will be resolved
  * !PostSolve - A contact between two Bodies was resolved

Some of the events above should return a boolean result.  The returned boolean indicates whether the processing of that contact should continue.

The !ContactAdapter, which is the default, will always return true for all the methods.

==Ray Cast Event==
When a ray cast is performed using the World.raycast methods two ray cast events may be triggered.

Notification of this event is by the !RaycastListener interface and !RaycastAdapter class.

There are two events, one for each Body and one for each !BodyFixture on each Body.  Each event returns a boolean value indicating that the World should or should not raycast the Body or !BodyFixture.  Implement these methods to ignore certain Bodies or !BodyFixtures.

==Time Of Impact Events==
If continuous collision detection (CCD) is disabled its possible that bodies traveling fast may pass through other objects within one time step.  If CCD is enabled, detection of these situations will generate time of impact events.

The single time of impact event can be listened for via the !TimeOfImpactListener interface or the !TimeOfImpactAdapter class.  

Returning a true value indicates that the event should be handled, returning false indicates that the event should be ignored.

Each event has specific information that can be useful for games.  Check the Javadocs for more information.